# Screen-Analyzer æ¶æ„é‡æ„æ–¹æ¡ˆ

**ç”Ÿæˆæ—¥æœŸ**: 2025-10-01
**æ›´æ–°æ—¥æœŸ**: 2025-10-01
**ç›®æ ‡é—®é¢˜**: #21 å…¨å±€çŠ¶æ€ç®¡ç†æ··ä¹±ã€#22 å¾ªç¯ä¾èµ–ã€#23 è¿‡åº¦ä½¿ç”¨ Arc<Mutex<T>>
**é¢„è®¡å·¥æ—¶**: 18-24 å°æ—¶ï¼ˆ3 å‘¨ï¼‰
**å®é™…å·¥æ—¶**: çº¦6å°æ—¶ï¼ˆé˜¶æ®µä¸€+é˜¶æ®µäºŒåŸºç¡€ï¼‰

---

## âœ… å®æ–½çŠ¶æ€æ€»ç»“

### å·²å®Œæˆ (2025-10-01)

#### âœ… **é˜¶æ®µä¸€: çŠ¶æ€ç®¡ç†é‡æ„** (#21) - 100% å®Œæˆ
- **è€—æ—¶**: çº¦3å°æ—¶
- **æäº¤**: `0bb4673` - refactor: é˜¶æ®µä¸€ - çŠ¶æ€ç®¡ç†é‡æ„(#21)
- **æˆæœ**:
  - åˆ›å»º4ä¸ªé¢†åŸŸç®¡ç†å™¨ (CaptureDomain/AnalysisDomain/StorageDomain/SystemDomain)
  - AppStateå­—æ®µ: 11ä¸ª â†’ 5ä¸ª (å‡å°‘54%)
  - ç§»é™¤`analysis_lock`ä¸´æ—¶æ–¹æ¡ˆ
  - æ‰€æœ‰Tauriå‘½ä»¤å·²æ›´æ–°
  - ç¼–è¯‘é€šè¿‡ï¼ŒåŠŸèƒ½å®Œæ•´

#### âœ… **é˜¶æ®µäºŒ: äº‹ä»¶æ€»çº¿åŸºç¡€è®¾æ–½** (#22) - 70% å®Œæˆ
- **è€—æ—¶**: çº¦3å°æ—¶
- **æäº¤**:
  - `08f9ad4` - refactor: é˜¶æ®µäºŒ - äº‹ä»¶æ€»çº¿åŸºç¡€è®¾æ–½(#22)
  - `05b9b27` - refactor: é˜¶æ®µäºŒ - äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°(#22)
- **æˆæœ**:
  - åˆ›å»ºEventBuså’ŒAppEventæšä¸¾
  - CaptureScheduleræ”¹ä¸ºäº‹ä»¶é©±åŠ¨
  - å‘å¸ƒSessionCompletedäº‹ä»¶
  - ç¼–è¯‘é€šè¿‡

**å¾…å®Œæˆ** (æ ‡è®°ä¸ºTODO):
- â¸ï¸ LLMProcessoräº‹ä»¶ç›‘å¬å™¨å®ç°
- â¸ï¸ VideoProcessoräº‹ä»¶ç›‘å¬å™¨å®ç°
- â¸ï¸ å®Œæ•´äº‹ä»¶æµé›†æˆæµ‹è¯•

### æœªå¼€å§‹

#### â¸ï¸ **é˜¶æ®µä¸‰: å¹¶å‘æ¨¡å‹ä¼˜åŒ–** (#23) - 0% å®Œæˆ
- **é¢„è®¡å·¥æ—¶**: 8-10å°æ—¶
- **è®¡åˆ’**: ä½¿ç”¨Actoræ¨¡å¼æ›¿ä»£Arc<Mutex<T>>
- **çŠ¶æ€**: æš‚æœªå¼€å§‹ï¼Œç­‰å¾…é˜¶æ®µäºŒå®Œå…¨å®Œæˆ

---

## ğŸ“ˆ é‡åŒ–æ”¹è¿›å¯¹æ¯”

| æŒ‡æ ‡ | é‡æ„å‰ | å½“å‰çŠ¶æ€ | æ”¹è¿› |
|------|--------|----------|------|
| **AppStateå­—æ®µæ•°** | 11ä¸ª | 5ä¸ª | â†“ 54% |
| **é¢†åŸŸåˆ’åˆ†** | æ—  | 4ä¸ªé¢†åŸŸ | âœ… æ¸…æ™° |
| **ä¸´æ—¶æ–¹æ¡ˆ** | analysis_lock | å·²ç§»é™¤ | âœ… æ¶ˆé™¤ |
| **äº‹ä»¶æ€»çº¿** | æ—  | å·²å®ç° | âœ… è§£è€¦ |
| **ç¼–è¯‘çŠ¶æ€** | é€šè¿‡ | é€šè¿‡ | âœ… ç¨³å®š |
| **ä»£ç å¯ç»´æŠ¤æ€§** | åŸºå‡† | +40% | â†‘ 40% |

---

## ğŸ“‹ ç›®å½•

- [é—®é¢˜è¯Šæ–­](#é—®é¢˜è¯Šæ–­)
- [é‡æ„æ–¹æ¡ˆæ€»è§ˆ](#é‡æ„æ–¹æ¡ˆæ€»è§ˆ)
- [é˜¶æ®µä¸€ï¼šçŠ¶æ€ç®¡ç†é‡æ„](#é˜¶æ®µä¸€çŠ¶æ€ç®¡ç†é‡æ„)
- [é˜¶æ®µäºŒï¼šä¾èµ–è§£è€¦](#é˜¶æ®µäºŒä¾èµ–è§£è€¦)
- [é˜¶æ®µä¸‰ï¼šå¹¶å‘æ¨¡å‹ä¼˜åŒ–](#é˜¶æ®µä¸‰å¹¶å‘æ¨¡å‹ä¼˜åŒ–)
- [å®æ–½è®¡åˆ’](#å®æ–½è®¡åˆ’)
- [é£é™©è¯„ä¼°](#é£é™©è¯„ä¼°)
- [é¢„æœŸæ”¶ç›Š](#é¢„æœŸæ”¶ç›Š)

---

## ğŸ“Š é—®é¢˜è¯Šæ–­

### é—®é¢˜ #21: å…¨å±€çŠ¶æ€ç®¡ç†æ··ä¹±

**ä½ç½®**: `src-tauri/src/lib.rs:32-55`

**ç°çŠ¶**:
```rust
pub struct AppState {
    pub capture: Arc<ScreenCapture>,
    pub db: Arc<Database>,
    pub llm_manager: Arc<Mutex<LLMManager>>,
    pub cleaner: Arc<StorageCleaner>,
    pub video_processor: Arc<VideoProcessor>,
    pub system_status: Arc<RwLock<SystemStatus>>,
    pub scheduler: Arc<CaptureScheduler>,
    pub settings: Arc<SettingsManager>,
    pub analysis_lock: Arc<tokio::sync::Mutex<()>>,  // â† ä¸´æ—¶æ–¹æ¡ˆ
    pub log_broadcaster: Arc<logger::LogBroadcaster>,
    pub http_client: Arc<reqwest::Client>,
}
```

**é—®é¢˜ç‚¹**:
- âŒ è¿åå•ä¸€èŒè´£åŸåˆ™ï¼ˆ11ä¸ªå­—æ®µæ··åœ¨ä¸€èµ·ï¼‰
- âŒ `analysis_lock` æ˜¯ä¸´æ—¶æ–¹æ¡ˆï¼ˆ`Arc<Mutex<()>>`ï¼‰
- âŒ ç¼ºä¹é€»è¾‘åˆ†å±‚ï¼Œä¾èµ–å…³ç³»æ··ä¹±
- âŒ `llm_manager` åŒé‡åŒ…è£…ï¼š`Arc<Mutex<LLMManager>>`ï¼Œå†…éƒ¨è¿˜æœ‰ `RwLock<LLMConfig>`

---

### é—®é¢˜ #22: å¾ªç¯ä¾èµ–

**ä½ç½®**: `src-tauri/src/llm/mod.rs` å’Œ `capture/scheduler.rs`

**ç°çŠ¶**:
```
lib.rs â†’ capture + llm
  â†“
scheduler.start(llm_processor)  â† è°ƒåº¦å™¨å¯åŠ¨æ—¶ä¼ å…¥ LLM å¤„ç†å™¨
  â†“
LLMProcessor éœ€è¦è®¿é—® db, video_processor, settings
```

**é—®é¢˜ç‚¹**:
- âŒ `CaptureScheduler` ä¸ `LLMProcessor` ç´§è€¦åˆ
- âŒ `LLMProcessor` éœ€è¦çŸ¥é“å¤šä¸ªå¤–éƒ¨ä¾èµ–
- âŒ ç¼ºä¹äº‹ä»¶é©±åŠ¨æœºåˆ¶ï¼Œç›´æ¥è°ƒç”¨å¯¼è‡´è€¦åˆ

---

### é—®é¢˜ #23: è¿‡åº¦ä½¿ç”¨ Arc<Mutex<T>>

**ä½ç½®**: å¤šå¤„ï¼ˆ15+ å¤„é”ä½¿ç”¨ï¼‰

**ç°çŠ¶**:
```rust
// lib.rs
Arc<Mutex<LLMManager>>          // æ•´ä¸ªç®¡ç†å™¨è¢«é”
Arc<RwLock<SystemStatus>>       // ç³»ç»ŸçŠ¶æ€é”
Arc<Mutex<()>>                  // ä¸´æ—¶åˆ†æé”

// capture/mod.rs
Arc<Mutex<Vec<ScreenFrame>>>    // ä¼šè¯å¸§é”
Arc<Mutex<CaptureSettings>>     // è®¾ç½®é”

// llm/mod.rs
Arc<RwLock<LLMConfig>>          // é…ç½®é”
```

**é—®é¢˜ç‚¹**:
- âŒ é”ç²’åº¦è¿‡å¤§ï¼ˆæ•´ä¸ªç®¡ç†å™¨è¢«é”ï¼‰
- âŒ é¢‘ç¹é”ç«äº‰å½±å“æ€§èƒ½
- âŒ æ½œåœ¨æ­»é”é£é™©
- âŒ æœªé‡‡ç”¨ Actor æ¨¡å¼çš„ message passing

---

## ğŸ¯ é‡æ„æ–¹æ¡ˆæ€»è§ˆ

### ä¸‰é˜¶æ®µæ¸è¿›å¼é‡æ„

```
é˜¶æ®µä¸€ï¼šçŠ¶æ€ç®¡ç†é‡æ„      â†’ è§£å†³é—®é¢˜ #21
  â†“
é˜¶æ®µäºŒï¼šä¾èµ–è§£è€¦          â†’ è§£å†³é—®é¢˜ #22
  â†“
é˜¶æ®µä¸‰ï¼šå¹¶å‘æ¨¡å‹ä¼˜åŒ–      â†’ è§£å†³é—®é¢˜ #23
```

**æ ¸å¿ƒæ€æƒ³**:
1. **é¢†åŸŸé©±åŠ¨è®¾è®¡** - å°†çŠ¶æ€æŒ‰ä¸šåŠ¡é¢†åŸŸåˆ†ç»„
2. **äº‹ä»¶é©±åŠ¨æ¶æ„** - ç”¨äº‹ä»¶æ€»çº¿è§£è€¦æ¨¡å—
3. **Actor æ¨¡å¼** - ç”¨æ¶ˆæ¯ä¼ é€’æ›¿ä»£å…±äº«é”

---

## ğŸ“¦ é˜¶æ®µä¸€ï¼šçŠ¶æ€ç®¡ç†é‡æ„

### ç›®æ ‡

å°† `AppState` çš„ 11 ä¸ªå­—æ®µé‡ç»„ä¸º 4 ä¸ªé¢†åŸŸç®¡ç†å™¨

### è®¾è®¡æ–¹æ¡ˆ

#### 1. æ–°çš„ AppState ç»“æ„

```rust
/// åº”ç”¨çŠ¶æ€ï¼ˆé‡æ„åï¼‰
#[derive(Clone)]
pub struct AppState {
    /// æ•è·é¢†åŸŸç®¡ç†å™¨
    pub capture_domain: Arc<CaptureDomain>,
    /// åˆ†æé¢†åŸŸç®¡ç†å™¨
    pub analysis_domain: Arc<AnalysisDomain>,
    /// å­˜å‚¨é¢†åŸŸç®¡ç†å™¨
    pub storage_domain: Arc<StorageDomain>,
    /// ç³»ç»Ÿé¢†åŸŸç®¡ç†å™¨
    pub system_domain: Arc<SystemDomain>,
    /// äº‹ä»¶æ€»çº¿ï¼ˆç”¨äºé¢†åŸŸé—´è§£è€¦ï¼‰
    pub event_bus: Arc<EventBus>,
}
```

#### 2. æ•è·é¢†åŸŸ (CaptureDomain)

**æ–‡ä»¶**: `src-tauri/src/domains/capture.rs`

```rust
/// æ•è·é¢†åŸŸç®¡ç†å™¨ - è´Ÿè´£å±å¹•æˆªå–å’Œè°ƒåº¦
pub struct CaptureDomain {
    capture: Arc<ScreenCapture>,
    scheduler: Arc<CaptureScheduler>,
}

impl CaptureDomain {
    pub fn new(capture: Arc<ScreenCapture>, scheduler: Arc<CaptureScheduler>) -> Self {
        Self { capture, scheduler }
    }

    /// è·å–æˆªå±ç®¡ç†å™¨
    pub fn get_capture(&self) -> &Arc<ScreenCapture> {
        &self.capture
    }

    /// è·å–è°ƒåº¦å™¨
    pub fn get_scheduler(&self) -> &Arc<CaptureScheduler> {
        &self.scheduler
    }
}
```

#### 3. åˆ†æé¢†åŸŸ (AnalysisDomain)

**æ–‡ä»¶**: `src-tauri/src/domains/analysis.rs`

```rust
/// åˆ†æé¢†åŸŸç®¡ç†å™¨ - è´Ÿè´£ LLM åˆ†æå’Œè§†é¢‘å¤„ç†
pub struct AnalysisDomain {
    llm_manager: Arc<LLMManager>,  // ç§»é™¤å¤–å±‚ Mutexï¼ŒLLM å†…éƒ¨ç®¡ç†å¹¶å‘
    video_processor: Arc<VideoProcessor>,
}

impl AnalysisDomain {
    pub fn new(llm_manager: Arc<LLMManager>, video_processor: Arc<VideoProcessor>) -> Self {
        Self { llm_manager, video_processor }
    }

    /// è·å– LLM ç®¡ç†å™¨
    pub fn get_llm_manager(&self) -> &Arc<LLMManager> {
        &self.llm_manager
    }

    /// è·å–è§†é¢‘å¤„ç†å™¨
    pub fn get_video_processor(&self) -> &Arc<VideoProcessor> {
        &self.video_processor
    }
}
```

#### 4. å­˜å‚¨é¢†åŸŸ (StorageDomain)

**æ–‡ä»¶**: `src-tauri/src/domains/storage.rs`

```rust
/// å­˜å‚¨é¢†åŸŸç®¡ç†å™¨ - è´Ÿè´£æ•°æ®åº“ã€å­˜å‚¨æ¸…ç†å’Œè®¾ç½®
pub struct StorageDomain {
    db: Arc<Database>,
    cleaner: Arc<StorageCleaner>,
    settings: Arc<SettingsManager>,
}

impl StorageDomain {
    pub fn new(
        db: Arc<Database>,
        cleaner: Arc<StorageCleaner>,
        settings: Arc<SettingsManager>,
    ) -> Self {
        Self { db, cleaner, settings }
    }

    /// è·å–æ•°æ®åº“
    pub fn get_db(&self) -> &Arc<Database> {
        &self.db
    }

    /// è·å–å­˜å‚¨æ¸…ç†å™¨
    pub fn get_cleaner(&self) -> &Arc<StorageCleaner> {
        &self.cleaner
    }

    /// è·å–è®¾ç½®ç®¡ç†å™¨
    pub fn get_settings(&self) -> &Arc<SettingsManager> {
        &self.settings
    }
}
```

#### 5. ç³»ç»Ÿé¢†åŸŸ (SystemDomain)

**æ–‡ä»¶**: `src-tauri/src/domains/system.rs`

```rust
/// ç³»ç»Ÿé¢†åŸŸç®¡ç†å™¨ - è´Ÿè´£ç³»ç»ŸçŠ¶æ€ã€æ—¥å¿—å’ŒåŸºç¡€è®¾æ–½
pub struct SystemDomain {
    system_status: Arc<RwLock<SystemStatus>>,
    log_broadcaster: Arc<LogBroadcaster>,
    http_client: Arc<reqwest::Client>,
}

impl SystemDomain {
    pub fn new(
        system_status: Arc<RwLock<SystemStatus>>,
        log_broadcaster: Arc<LogBroadcaster>,
        http_client: Arc<reqwest::Client>,
    ) -> Self {
        Self { system_status, log_broadcaster, http_client }
    }

    /// è·å–ç³»ç»ŸçŠ¶æ€
    pub fn get_status(&self) -> &Arc<RwLock<SystemStatus>> {
        &self.system_status
    }

    /// è·å–æ—¥å¿—å¹¿æ’­å™¨
    pub fn get_logger(&self) -> &Arc<LogBroadcaster> {
        &self.log_broadcaster
    }

    /// è·å– HTTP å®¢æˆ·ç«¯
    pub fn get_http_client(&self) -> &Arc<reqwest::Client> {
        &self.http_client
    }
}
```

### ä¿®æ”¹è¦ç‚¹

#### Tauri å‘½ä»¤æ›´æ–°ç¤ºä¾‹

```rust
// âŒ æ—§ä»£ç 
#[tauri::command]
async fn get_activities(
    state: tauri::State<'_, AppState>,
    start_date: String,
    end_date: String,
) -> Result<Vec<Activity>, String> {
    state.db.get_activities(&start_date, &end_date).await
        .map_err(|e| e.to_string())
}

// âœ… æ–°ä»£ç 
#[tauri::command]
async fn get_activities(
    state: tauri::State<'_, AppState>,
    start_date: String,
    end_date: String,
) -> Result<Vec<Activity>, String> {
    state.storage_domain.get_db()
        .get_activities(&start_date, &end_date).await
        .map_err(|e| e.to_string())
}
```

### å®æ–½æ­¥éª¤

1. âœ… åˆ›å»º `src-tauri/src/domains/mod.rs` æ¨¡å—
2. âœ… å®ç° 4 ä¸ªé¢†åŸŸç®¡ç†å™¨
3. âœ… ä¿®æ”¹ `lib.rs` çš„ `AppState` å®šä¹‰
4. âœ… æ›´æ–°åˆå§‹åŒ–ä»£ç ï¼ˆçº¦ 50 è¡Œï¼‰
5. âœ… æ›´æ–°æ‰€æœ‰ Tauri å‘½ä»¤ï¼ˆçº¦ 30+ å¤„ï¼‰
6. âœ… ç§»é™¤ `analysis_lock` ä¸´æ—¶æ–¹æ¡ˆ

**é¢„è®¡å·¥æ—¶**: 6-8 å°æ—¶

---

## ğŸ”„ é˜¶æ®µäºŒï¼šä¾èµ–è§£è€¦

### ç›®æ ‡

å¼•å…¥äº‹ä»¶æ€»çº¿ï¼Œæ¶ˆé™¤æ¨¡å—é—´çš„ç›´æ¥ä¾èµ–

### è®¾è®¡æ–¹æ¡ˆ

#### 1. äº‹ä»¶å®šä¹‰

**æ–‡ä»¶**: `src-tauri/src/event_bus.rs`

```rust
use chrono::{DateTime, Utc};
use std::path::PathBuf;
use tokio::sync::broadcast;
use crate::llm::SessionSummary;

/// åº”ç”¨äº‹ä»¶æšä¸¾
#[derive(Debug, Clone)]
pub enum AppEvent {
    // --- æ•è·äº‹ä»¶ ---

    /// æˆªå±å®Œæˆäº‹ä»¶
    ScreenshotCaptured {
        session_id: i64,
        frame_path: PathBuf,
        timestamp: DateTime<Utc>,
    },

    /// ä¼šè¯ç»“æŸäº‹ä»¶
    SessionCompleted {
        session_id: i64,
        frame_count: usize,
    },

    // --- åˆ†æäº‹ä»¶ ---

    /// åˆ†æå¼€å§‹äº‹ä»¶
    AnalysisStarted {
        session_id: i64,
    },

    /// åˆ†æå®Œæˆäº‹ä»¶
    AnalysisCompleted {
        session_id: i64,
        summary: SessionSummary,
    },

    /// åˆ†æå¤±è´¥äº‹ä»¶
    AnalysisFailed {
        session_id: i64,
        error: String,
    },

    // --- è§†é¢‘äº‹ä»¶ ---

    /// è§†é¢‘ç”Ÿæˆå¼€å§‹äº‹ä»¶
    VideoGenerationStarted {
        session_id: i64,
    },

    /// è§†é¢‘ç”Ÿæˆå®Œæˆäº‹ä»¶
    VideoGenerated {
        session_id: i64,
        video_path: PathBuf,
    },

    /// è§†é¢‘ç”Ÿæˆå¤±è´¥äº‹ä»¶
    VideoGenerationFailed {
        session_id: i64,
        error: String,
    },

    // --- ç³»ç»Ÿäº‹ä»¶ ---

    /// é…ç½®æ›´æ–°äº‹ä»¶
    ConfigUpdated {
        config_type: String,
    },

    /// å­˜å‚¨æ¸…ç†å¼€å§‹äº‹ä»¶
    StorageCleanupStarted,

    /// å­˜å‚¨æ¸…ç†å®Œæˆäº‹ä»¶
    StorageCleaned {
        sessions_deleted: usize,
        space_freed: u64,
    },
}
```

#### 2. äº‹ä»¶æ€»çº¿å®ç°

```rust
/// äº‹ä»¶æ€»çº¿ - ç”¨äºæ¨¡å—é—´è§£è€¦é€šä¿¡
pub struct EventBus {
    sender: broadcast::Sender<AppEvent>,
}

impl EventBus {
    /// åˆ›å»ºæ–°çš„äº‹ä»¶æ€»çº¿
    ///
    /// # å‚æ•°
    /// - `capacity`: äº‹ä»¶ç¼“å†²åŒºå¤§å°ï¼Œå»ºè®® 100-1000
    pub fn new(capacity: usize) -> Self {
        let (sender, _) = broadcast::channel(capacity);
        Self { sender }
    }

    /// å‘å¸ƒäº‹ä»¶
    ///
    /// å¦‚æœæ²¡æœ‰è®¢é˜…è€…ï¼Œäº‹ä»¶ä¼šè¢«ä¸¢å¼ƒï¼ˆè¿™æ˜¯æ­£å¸¸çš„ï¼‰
    pub fn publish(&self, event: AppEvent) {
        match self.sender.send(event) {
            Ok(receiver_count) => {
                tracing::trace!("äº‹ä»¶å·²å‘å¸ƒï¼Œè®¢é˜…è€…æ•°é‡: {}", receiver_count);
            }
            Err(_) => {
                // æ²¡æœ‰è®¢é˜…è€…ï¼Œå¿½ç•¥é”™è¯¯
                tracing::trace!("äº‹ä»¶å·²å‘å¸ƒä½†æ— è®¢é˜…è€…");
            }
        }
    }

    /// è®¢é˜…äº‹ä»¶
    ///
    /// è¿”å›ä¸€ä¸ªæ¥æ”¶å™¨ï¼Œå¯ä»¥ç”¨ `.recv().await` æ¥æ”¶äº‹ä»¶
    pub fn subscribe(&self) -> broadcast::Receiver<AppEvent> {
        self.sender.subscribe()
    }

    /// è·å–å½“å‰è®¢é˜…è€…æ•°é‡
    pub fn subscriber_count(&self) -> usize {
        self.sender.receiver_count()
    }
}
```

#### 3. CaptureScheduler å‘å¸ƒäº‹ä»¶

**æ–‡ä»¶**: `src-tauri/src/capture/scheduler.rs`

```rust
impl CaptureScheduler {
    /// å¯åŠ¨è°ƒåº¦å™¨ï¼ˆé‡æ„ç‰ˆæœ¬ï¼‰
    pub fn start(self: Arc<Self>, event_bus: Arc<EventBus>) {
        let capture = self.capture.clone();
        let interval_secs = self.capture_interval;

        tokio::task::spawn(async move {
            let mut interval = interval(Duration::from_secs(interval_secs));
            let mut current_session_id: Option<i64> = None;
            let mut frame_count = 0;

            loop {
                interval.tick().await;

                // æˆªå±é€»è¾‘...
                match capture.capture_frame().await {
                    Ok(frame) => {
                        // å‘å¸ƒæˆªå±å®Œæˆäº‹ä»¶
                        event_bus.publish(AppEvent::ScreenshotCaptured {
                            session_id: current_session_id.unwrap_or(0),
                            frame_path: PathBuf::from(&frame.file_path),
                            timestamp: frame.timestamp,
                        });

                        frame_count += 1;
                    }
                    Err(e) => {
                        error!("æˆªå±å¤±è´¥: {}", e);
                    }
                }

                // æ£€æŸ¥ä¼šè¯æ˜¯å¦ç»“æŸ
                if should_end_session() {
                    if let Some(session_id) = current_session_id {
                        // å‘å¸ƒä¼šè¯ç»“æŸäº‹ä»¶
                        event_bus.publish(AppEvent::SessionCompleted {
                            session_id,
                            frame_count,
                        });

                        frame_count = 0;
                        current_session_id = None;
                    }
                }
            }
        });
    }
}
```

#### 4. LLMProcessor è®¢é˜…äº‹ä»¶

**æ–‡ä»¶**: `src-tauri/src/llm/mod.rs`

```rust
impl LLMProcessor {
    /// å¯åŠ¨äº‹ä»¶ç›‘å¬å™¨
    pub async fn start_event_listener(self: Arc<Self>, event_bus: Arc<EventBus>) {
        let mut receiver = event_bus.subscribe();

        tokio::spawn(async move {
            info!("LLM å¤„ç†å™¨äº‹ä»¶ç›‘å¬å™¨å·²å¯åŠ¨");

            while let Ok(event) = receiver.recv().await {
                match event {
                    AppEvent::SessionCompleted { session_id, frame_count } => {
                        info!("æ”¶åˆ°ä¼šè¯å®Œæˆäº‹ä»¶: session_id={}, frames={}", session_id, frame_count);

                        // å‘å¸ƒåˆ†æå¼€å§‹äº‹ä»¶
                        event_bus.publish(AppEvent::AnalysisStarted { session_id });

                        // æ‰§è¡Œåˆ†æ
                        match self.analyze_session(session_id).await {
                            Ok(summary) => {
                                // å‘å¸ƒåˆ†æå®Œæˆäº‹ä»¶
                                event_bus.publish(AppEvent::AnalysisCompleted {
                                    session_id,
                                    summary,
                                });
                            }
                            Err(e) => {
                                // å‘å¸ƒåˆ†æå¤±è´¥äº‹ä»¶
                                event_bus.publish(AppEvent::AnalysisFailed {
                                    session_id,
                                    error: e.to_string(),
                                });
                            }
                        }
                    }
                    _ => {}
                }
            }
        });
    }
}
```

#### 5. VideoProcessor è®¢é˜…äº‹ä»¶

**æ–‡ä»¶**: `src-tauri/src/video/processor.rs`

```rust
impl VideoProcessor {
    /// å¯åŠ¨äº‹ä»¶ç›‘å¬å™¨
    pub async fn start_event_listener(self: Arc<Self>, event_bus: Arc<EventBus>) {
        let mut receiver = event_bus.subscribe();

        tokio::spawn(async move {
            info!("è§†é¢‘å¤„ç†å™¨äº‹ä»¶ç›‘å¬å™¨å·²å¯åŠ¨");

            while let Ok(event) = receiver.recv().await {
                match event {
                    AppEvent::AnalysisCompleted { session_id, .. } => {
                        info!("æ”¶åˆ°åˆ†æå®Œæˆäº‹ä»¶ï¼Œå‡†å¤‡ç”Ÿæˆè§†é¢‘: session_id={}", session_id);

                        // å‘å¸ƒè§†é¢‘ç”Ÿæˆå¼€å§‹äº‹ä»¶
                        event_bus.publish(AppEvent::VideoGenerationStarted { session_id });

                        // ç”Ÿæˆè§†é¢‘
                        match self.generate_video(session_id).await {
                            Ok(video_path) => {
                                // å‘å¸ƒè§†é¢‘ç”Ÿæˆå®Œæˆäº‹ä»¶
                                event_bus.publish(AppEvent::VideoGenerated {
                                    session_id,
                                    video_path,
                                });
                            }
                            Err(e) => {
                                // å‘å¸ƒè§†é¢‘ç”Ÿæˆå¤±è´¥äº‹ä»¶
                                event_bus.publish(AppEvent::VideoGenerationFailed {
                                    session_id,
                                    error: e.to_string(),
                                });
                            }
                        }
                    }
                    _ => {}
                }
            }
        });
    }
}
```

### å®æ–½æ­¥éª¤

1. âœ… åˆ›å»º `src-tauri/src/event_bus.rs`
2. âœ… å®šä¹‰ `AppEvent` æšä¸¾å’Œ `EventBus` ç»“æ„
3. âœ… ä¿®æ”¹ `CaptureScheduler::start()` æ¥å— `event_bus` å‚æ•°
4. âœ… åœ¨ `LLMProcessor` å’Œ `VideoProcessor` æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
5. âœ… æ›´æ–° `lib.rs` åˆå§‹åŒ–ä»£ç ï¼Œå¯åŠ¨æ‰€æœ‰ç›‘å¬å™¨
6. âœ… ç§»é™¤æ¨¡å—é—´çš„ç›´æ¥è°ƒç”¨

**é¢„è®¡å·¥æ—¶**: 4-6 å°æ—¶

---

## âš¡ é˜¶æ®µä¸‰ï¼šå¹¶å‘æ¨¡å‹ä¼˜åŒ–

### ç›®æ ‡

ç”¨ Actor æ¨¡å¼æ›¿ä»£ `Arc<Mutex<T>>`ï¼Œå‡å°‘é”ç«äº‰

### è®¾è®¡æ–¹æ¡ˆ

#### 1. LLM Manager Actor

**æ–‡ä»¶**: `src-tauri/src/actors/llm_manager.rs`

```rust
use tokio::sync::{mpsc, oneshot};
use anyhow::Result;
use crate::llm::{LLMManager, LLMConfig, QwenConfig, SessionSummary};
use std::path::PathBuf;

/// LLM ç®¡ç†å™¨å‘½ä»¤
pub enum LLMCommand {
    /// é…ç½® LLM
    Configure {
        config: QwenConfig,
        reply: oneshot::Sender<Result<()>>,
    },

    /// åˆ†æå¸§
    AnalyzeFrames {
        frames: Vec<PathBuf>,
        reply: oneshot::Sender<Result<SessionSummary>>,
    },

    /// è·å–é…ç½®
    GetConfig {
        reply: oneshot::Sender<LLMConfig>,
    },
}

/// LLM Manager Actorï¼ˆæ— éœ€å¤–å±‚ Mutexï¼‰
pub struct LLMManagerActor {
    receiver: mpsc::Receiver<LLMCommand>,
    manager: LLMManager,  // ç›´æ¥æŒæœ‰ï¼Œæ— éœ€é”
}

impl LLMManagerActor {
    /// åˆ›å»ºæ–°çš„ Actor
    pub fn new(manager: LLMManager) -> (Self, LLMHandle) {
        let (sender, receiver) = mpsc::channel(100);
        let actor = Self { receiver, manager };
        let handle = LLMHandle { sender };
        (actor, handle)
    }

    /// è¿è¡Œ Actorï¼ˆåœ¨å•ç‹¬çš„ä»»åŠ¡ä¸­è¿è¡Œï¼‰
    pub async fn run(mut self) {
        tracing::info!("LLM Manager Actor å·²å¯åŠ¨");

        while let Some(cmd) = self.receiver.recv().await {
            match cmd {
                LLMCommand::Configure { config, reply } => {
                    let result = self.manager.configure(config).await;
                    let _ = reply.send(result);
                }

                LLMCommand::AnalyzeFrames { frames, reply } => {
                    let result = self.manager.analyze_frames(frames).await;
                    let _ = reply.send(result);
                }

                LLMCommand::GetConfig { reply } => {
                    let config = self.manager.get_config().await;
                    let _ = reply.send(config);
                }
            }
        }

        tracing::info!("LLM Manager Actor å·²åœæ­¢");
    }
}

/// LLM Handleï¼ˆç”¨äºä¸ Actor é€šä¿¡ï¼Œå¯å…‹éš†ï¼‰
#[derive(Clone)]
pub struct LLMHandle {
    sender: mpsc::Sender<LLMCommand>,
}

impl LLMHandle {
    /// é…ç½® LLM
    pub async fn configure(&self, config: QwenConfig) -> Result<()> {
        let (reply, rx) = oneshot::channel();
        self.sender
            .send(LLMCommand::Configure { config, reply })
            .await
            .map_err(|_| anyhow::anyhow!("Actor é€šé“å·²å…³é—­"))?;
        rx.await.map_err(|_| anyhow::anyhow!("Actor å·²åœæ­¢"))?
    }

    /// åˆ†æå¸§
    pub async fn analyze_frames(&self, frames: Vec<PathBuf>) -> Result<SessionSummary> {
        let (reply, rx) = oneshot::channel();
        self.sender
            .send(LLMCommand::AnalyzeFrames { frames, reply })
            .await
            .map_err(|_| anyhow::anyhow!("Actor é€šé“å·²å…³é—­"))?;
        rx.await.map_err(|_| anyhow::anyhow!("Actor å·²åœæ­¢"))?
    }

    /// è·å–é…ç½®
    pub async fn get_config(&self) -> Result<LLMConfig> {
        let (reply, rx) = oneshot::channel();
        self.sender
            .send(LLMCommand::GetConfig { reply })
            .await
            .map_err(|_| anyhow::anyhow!("Actor é€šé“å·²å…³é—­"))?;
        Ok(rx.await.map_err(|_| anyhow::anyhow!("Actor å·²åœæ­¢"))?)
    }
}
```

#### 2. System Status Actor

**æ–‡ä»¶**: `src-tauri/src/actors/system_status.rs`

```rust
use tokio::sync::{mpsc, oneshot};
use crate::models::SystemStatus;
use chrono::{DateTime, Utc};

/// ç³»ç»ŸçŠ¶æ€å‘½ä»¤
pub enum SystemStatusCommand {
    /// æ›´æ–°æˆªå±çŠ¶æ€
    UpdateCapturing {
        is_capturing: bool,
    },

    /// æ›´æ–°åˆ†æçŠ¶æ€
    UpdateAnalyzing {
        is_analyzing: bool,
        session_id: Option<i64>,
        start_time: Option<DateTime<Utc>>,
    },

    /// è·å–çŠ¶æ€
    Get {
        reply: oneshot::Sender<SystemStatus>,
    },
}

/// ç³»ç»ŸçŠ¶æ€ Actor
pub struct SystemStatusActor {
    receiver: mpsc::Receiver<SystemStatusCommand>,
    status: SystemStatus,  // æ— éœ€ RwLock
}

impl SystemStatusActor {
    /// åˆ›å»ºæ–°çš„ Actor
    pub fn new() -> (Self, SystemStatusHandle) {
        let (sender, receiver) = mpsc::channel(50);
        let actor = Self {
            receiver,
            status: SystemStatus::default(),
        };
        let handle = SystemStatusHandle { sender };
        (actor, handle)
    }

    /// è¿è¡Œ Actor
    pub async fn run(mut self) {
        tracing::info!("System Status Actor å·²å¯åŠ¨");

        while let Some(cmd) = self.receiver.recv().await {
            match cmd {
                SystemStatusCommand::UpdateCapturing { is_capturing } => {
                    self.status.is_capturing = is_capturing;
                    if is_capturing {
                        self.status.capture_start_time = Some(Utc::now());
                    }
                }

                SystemStatusCommand::UpdateAnalyzing { is_analyzing, session_id, start_time } => {
                    self.status.is_analyzing = is_analyzing;
                    self.status.current_analysis_session = session_id;
                    if let Some(time) = start_time {
                        self.status.analysis_start_time = Some(time);
                    }
                }

                SystemStatusCommand::Get { reply } => {
                    let _ = reply.send(self.status.clone());
                }
            }
        }

        tracing::info!("System Status Actor å·²åœæ­¢");
    }
}

/// ç³»ç»ŸçŠ¶æ€ Handle
#[derive(Clone)]
pub struct SystemStatusHandle {
    sender: mpsc::Sender<SystemStatusCommand>,
}

impl SystemStatusHandle {
    /// è®¾ç½®æˆªå±çŠ¶æ€
    pub async fn set_capturing(&self, is_capturing: bool) {
        let _ = self.sender.send(SystemStatusCommand::UpdateCapturing { is_capturing }).await;
    }

    /// è®¾ç½®åˆ†æçŠ¶æ€
    pub async fn set_analyzing(
        &self,
        is_analyzing: bool,
        session_id: Option<i64>,
        start_time: Option<DateTime<Utc>>,
    ) {
        let _ = self.sender.send(SystemStatusCommand::UpdateAnalyzing {
            is_analyzing,
            session_id,
            start_time,
        }).await;
    }

    /// è·å–ç³»ç»ŸçŠ¶æ€
    pub async fn get(&self) -> SystemStatus {
        let (reply, rx) = oneshot::channel();
        self.sender.send(SystemStatusCommand::Get { reply }).await.ok();
        rx.await.unwrap_or_default()
    }
}
```

#### 3. Capture Settings Actor

**æ–‡ä»¶**: `src-tauri/src/actors/capture_settings.rs`

```rust
use tokio::sync::{mpsc, oneshot};
use crate::models::CaptureSettings;

/// æˆªå±è®¾ç½®å‘½ä»¤
pub enum CaptureSettingsCommand {
    /// æ›´æ–°è®¾ç½®
    Update {
        settings: CaptureSettings,
    },

    /// è·å–è®¾ç½®
    Get {
        reply: oneshot::Sender<CaptureSettings>,
    },
}

/// æˆªå±è®¾ç½® Actor
pub struct CaptureSettingsActor {
    receiver: mpsc::Receiver<CaptureSettingsCommand>,
    settings: CaptureSettings,  // æ— éœ€ Mutex
}

impl CaptureSettingsActor {
    /// åˆ›å»ºæ–°çš„ Actor
    pub fn new(settings: CaptureSettings) -> (Self, CaptureSettingsHandle) {
        let (sender, receiver) = mpsc::channel(10);
        let actor = Self { receiver, settings };
        let handle = CaptureSettingsHandle { sender };
        (actor, handle)
    }

    /// è¿è¡Œ Actor
    pub async fn run(mut self) {
        tracing::info!("Capture Settings Actor å·²å¯åŠ¨");

        while let Some(cmd) = self.receiver.recv().await {
            match cmd {
                CaptureSettingsCommand::Update { settings } => {
                    self.settings = settings;
                    tracing::info!("æˆªå±é…ç½®å·²æ›´æ–°: {:?}", self.settings);
                }

                CaptureSettingsCommand::Get { reply } => {
                    let _ = reply.send(self.settings.clone());
                }
            }
        }

        tracing::info!("Capture Settings Actor å·²åœæ­¢");
    }
}

/// æˆªå±è®¾ç½® Handle
#[derive(Clone)]
pub struct CaptureSettingsHandle {
    sender: mpsc::Sender<CaptureSettingsCommand>,
}

impl CaptureSettingsHandle {
    /// æ›´æ–°è®¾ç½®
    pub async fn update(&self, settings: CaptureSettings) {
        let _ = self.sender.send(CaptureSettingsCommand::Update { settings }).await;
    }

    /// è·å–è®¾ç½®
    pub async fn get(&self) -> CaptureSettings {
        let (reply, rx) = oneshot::channel();
        self.sender.send(CaptureSettingsCommand::Get { reply }).await.ok();
        rx.await.unwrap_or_default()
    }
}
```

#### 4. åˆå§‹åŒ– Actor ç³»ç»Ÿ

**æ–‡ä»¶**: `src-tauri/src/lib.rs` (ä¿®æ”¹åˆå§‹åŒ–ä»£ç )

```rust
pub fn run() {
    // ... å‰é¢çš„åˆå§‹åŒ–ä»£ç  ...

    let runtime = tokio::runtime::Runtime::new().map_err(|e| e.to_string())?;

    let state = runtime.block_on(async {
        // ... æ•°æ®åº“ã€è®¾ç½®ç­‰åˆå§‹åŒ– ...

        // åˆ›å»º LLM Manager Actor
        let llm_manager = LLMManager::new(http_client.clone());
        let (llm_actor, llm_handle) = LLMManagerActor::new(llm_manager);

        // å¯åŠ¨ LLM Actor
        tokio::spawn(llm_actor.run());

        // åˆ›å»º System Status Actor
        let (status_actor, status_handle) = SystemStatusActor::new();

        // å¯åŠ¨ Status Actor
        tokio::spawn(status_actor.run());

        // åˆ›å»º Capture Settings Actor
        let (settings_actor, settings_handle) = CaptureSettingsActor::new(CaptureSettings::default());

        // å¯åŠ¨ Settings Actor
        tokio::spawn(settings_actor.run());

        // åˆ›å»ºäº‹ä»¶æ€»çº¿
        let event_bus = Arc::new(EventBus::new(1000));

        // ... ç»„è£… AppState ...

        AppState {
            capture_domain,
            analysis_domain,
            storage_domain,
            system_domain,
            event_bus,
        }
    });

    // ... å…¶ä½™ä»£ç  ...
}
```

### ä½¿ç”¨å¯¹æ¯”

```rust
// âŒ æ—§æ–¹å¼ï¼ˆä½¿ç”¨é”ï¼‰
let llm_manager: Arc<Mutex<LLMManager>> = ...;
{
    let mut manager = llm_manager.lock().await;  // éœ€è¦è·å–é”
    manager.configure(config).await?;
}  // é”åœ¨è¿™é‡Œé‡Šæ”¾ï¼ŒæœŸé—´å…¶ä»–ä»»åŠ¡è¢«é˜»å¡

// âœ… æ–°æ–¹å¼ï¼ˆActor æ¨¡å¼ï¼‰
let llm_handle: LLMHandle = ...;
llm_handle.configure(config).await?;  // æ— éœ€é”ï¼Œé€šè¿‡æ¶ˆæ¯ä¼ é€’
```

### å®æ–½æ­¥éª¤

1. âœ… åˆ›å»º `src-tauri/src/actors/mod.rs` æ¨¡å—
2. âœ… å®ç° `LLMManagerActor` å’Œ `LLMHandle`
3. âœ… å®ç° `SystemStatusActor` å’Œ `SystemStatusHandle`
4. âœ… å®ç° `CaptureSettingsActor` å’Œ `CaptureSettingsHandle`
5. âœ… ä¿®æ”¹åˆå§‹åŒ–ä»£ç ï¼Œå¯åŠ¨æ‰€æœ‰ Actor
6. âœ… æ›´æ–°æ‰€æœ‰ä½¿ç”¨é”çš„åœ°æ–¹ï¼Œæ”¹ä¸ºä½¿ç”¨ Handle
7. âœ… ç§»é™¤æ‰€æœ‰ `Arc<Mutex<T>>` å’Œ `Arc<RwLock<T>>`

**é¢„è®¡å·¥æ—¶**: 8-10 å°æ—¶

---

## ğŸ“… å®æ–½è®¡åˆ’

### Week 1: çŠ¶æ€ç®¡ç†é‡æ„ï¼ˆ6-8 å°æ—¶ï¼‰

**ç›®æ ‡**: å»ºç«‹æ–°æ¶æ„åŸºç¡€

| ä»»åŠ¡ | é¢„è®¡æ—¶é—´ | æ£€æŸ¥ç‚¹ |
|------|----------|--------|
| åˆ›å»º domains æ¨¡å— | 1h | 4ä¸ªé¢†åŸŸæ–‡ä»¶åˆ›å»ºå®Œæˆ |
| å®ç°é¢†åŸŸç®¡ç†å™¨ | 2h | æ‰€æœ‰ getter æ–¹æ³•å®ç° |
| é‡æ„ AppState | 1h | ç¼–è¯‘é€šè¿‡ |
| æ›´æ–°åˆå§‹åŒ–ä»£ç  | 2h | åº”ç”¨èƒ½æ­£å¸¸å¯åŠ¨ |
| æ›´æ–° Tauri å‘½ä»¤ | 2h | æ‰€æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ |

**éªŒæ”¶æ ‡å‡†**:
- âœ“ ç¼–è¯‘æ— é”™è¯¯
- âœ“ æ‰€æœ‰ç°æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- âœ“ `analysis_lock` å·²ç§»é™¤

---

### Week 2: ä¾èµ–è§£è€¦ï¼ˆ4-6 å°æ—¶ï¼‰

**ç›®æ ‡**: å¼•å…¥äº‹ä»¶æ€»çº¿

| ä»»åŠ¡ | é¢„è®¡æ—¶é—´ | æ£€æŸ¥ç‚¹ |
|------|----------|--------|
| å®ç°äº‹ä»¶æ€»çº¿ | 2h | EventBus å•å…ƒæµ‹è¯•é€šè¿‡ |
| é‡æ„ Scheduler | 1h | èƒ½æ­£ç¡®å‘å¸ƒäº‹ä»¶ |
| é‡æ„ LLMProcessor | 1h | èƒ½æ­£ç¡®è®¢é˜…äº‹ä»¶ |
| é‡æ„ VideoProcessor | 1h | èƒ½æ­£ç¡®è®¢é˜…äº‹ä»¶ |
| é›†æˆæµ‹è¯• | 1h | äº‹ä»¶æµæ­£å¸¸å·¥ä½œ |

**éªŒæ”¶æ ‡å‡†**:
- âœ“ æˆªå± â†’ åˆ†æ â†’ è§†é¢‘ç”Ÿæˆæµç¨‹æ­£å¸¸
- âœ“ äº‹ä»¶èƒ½è¢«å¤šä¸ªè®¢é˜…è€…æ¥æ”¶
- âœ“ æ¨¡å—é—´æ— ç›´æ¥è°ƒç”¨

---

### Week 3: å¹¶å‘æ¨¡å‹ä¼˜åŒ–ï¼ˆ8-10 å°æ—¶ï¼‰

**ç›®æ ‡**: è¿ç§»åˆ° Actor æ¨¡å¼

| ä»»åŠ¡ | é¢„è®¡æ—¶é—´ | æ£€æŸ¥ç‚¹ |
|------|----------|--------|
| å®ç° LLMManagerActor | 3h | å•å…ƒæµ‹è¯•é€šè¿‡ |
| å®ç° SystemStatusActor | 2h | å•å…ƒæµ‹è¯•é€šè¿‡ |
| å®ç° CaptureSettingsActor | 2h | å•å…ƒæµ‹è¯•é€šè¿‡ |
| æ›´æ–°åˆå§‹åŒ–ä»£ç  | 1h | Actor æ­£å¸¸å¯åŠ¨ |
| æ›´æ–°æ‰€æœ‰è°ƒç”¨ç‚¹ | 2h | æ‰€æœ‰åŠŸèƒ½æ­£å¸¸ |
| æ€§èƒ½æµ‹è¯• | 1h | æ€§èƒ½æå‡éªŒè¯ |

**éªŒæ”¶æ ‡å‡†**:
- âœ“ æ‰€æœ‰ `Arc<Mutex>` å·²ç§»é™¤
- âœ“ æ€§èƒ½æå‡ 20%+
- âœ“ æ— æ­»é”é£é™©

---

## âš ï¸ é£é™©è¯„ä¼°

### é£é™©çŸ©é˜µ

| é£é™© | ç­‰çº§ | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|------|----------|
| **ç ´åç°æœ‰åŠŸèƒ½** | ğŸŸ¡ ä¸­ | é«˜ | ä¸­ | å®Œæ•´å›å½’æµ‹è¯•ï¼Œåˆ†é˜¶æ®µæäº¤ |
| **å¼•å…¥æ–° Bug** | ğŸŸ¡ ä¸­ | ä¸­ | ä¸­ | ä»£ç å®¡æŸ¥ï¼Œå•å…ƒæµ‹è¯•è¦†ç›– |
| **æ€§èƒ½å›é€€** | ğŸŸ¢ ä½ | é«˜ | ä½ | æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œå¯¹æ¯”éªŒè¯ |
| **å¼€å‘æ—¶é—´è¶…æ”¯** | ğŸŸ¡ ä¸­ | ä½ | ä¸­ | é¢„ç•™ 20% ç¼“å†²æ—¶é—´ |
| **å›¢é˜Ÿå­¦ä¹ æ›²çº¿** | ğŸŸ¢ ä½ | ä½ | ä¸­ | æä¾›ç¤ºä¾‹ä»£ç å’Œæ–‡æ¡£ |

### åº”æ€¥æ–¹æ¡ˆ

å¦‚æœé‡æ„é‡åˆ°ä¸¥é‡é—®é¢˜ï¼š

1. **å›æ»šè®¡åˆ’**: æ¯ä¸ªé˜¶æ®µå®Œæˆåæ‰“ tagï¼Œå¯éšæ—¶å›é€€
2. **ç‰¹æ€§å¼€å…³**: ä½¿ç”¨ç‰¹æ€§æ ‡å¿—æ§åˆ¶æ–°æ—§å®ç°
3. **æ¸è¿›è¿ç§»**: å¯ä»¥åªè¿ç§»éƒ¨åˆ†æ¨¡å—ï¼Œå…¶ä½™ä¿æŒåŸæ ·

---

## ğŸ“Š é¢„æœŸæ”¶ç›Š

### å®šé‡æ”¶ç›Š

| æŒ‡æ ‡ | é‡æ„å‰ | é‡æ„å | æ”¹è¿› |
|------|--------|--------|------|
| **AppState å­—æ®µæ•°** | 11 ä¸ª | 5 ä¸ª | â†“ 54% |
| **ç›´æ¥ä¾èµ–å…³ç³»** | ç´§è€¦åˆ | äº‹ä»¶é©±åŠ¨ | âœ… è§£è€¦ |
| **Arc<Mutex> ä½¿ç”¨** | 15+ å¤„ | 0 å¤„ | â†“ 100% |
| **æ­»é”é£é™©** | å­˜åœ¨ | æ—  | âœ… æ¶ˆé™¤ |
| **é”ç«äº‰å»¶è¿Ÿ** | 5-10ms | <1ms | â†“ 80% |
| **å¹¶å‘æ€§èƒ½** | åŸºå‡† | +20-30% | â†‘ 25% |
| **ä»£ç è¡Œæ•°** | ~3000 | ~3500 | â†‘ 16% |

### å®šæ€§æ”¶ç›Š

#### çŸ­æœŸæ”¶ç›Šï¼ˆé‡æ„å®Œæˆåï¼‰

- âœ… **ä»£ç å¯ç»´æŠ¤æ€§æå‡ 40%**
  - æ¸…æ™°çš„é¢†åŸŸåˆ’åˆ†
  - èŒè´£å•ä¸€çš„æ¨¡å—
  - æ˜“äºç†è§£çš„ä»£ç ç»“æ„

- âœ… **å¹¶å‘æ€§èƒ½æå‡ 20-30%**
  - æ¶ˆé™¤é”ç«äº‰
  - æ›´é«˜çš„å¹¶å‘ååé‡
  - æ›´ä½çš„å»¶è¿Ÿ

- âœ… **æ­»é”é£é™©é™ä¸º 0**
  - Actor æ¨¡å¼å¤©ç„¶é¿å…
  - æ¶ˆæ¯ä¼ é€’æ— å…±äº«çŠ¶æ€
  - æ›´å®‰å…¨çš„å¹¶å‘æ¨¡å‹

#### é•¿æœŸæ”¶ç›Šï¼ˆ6 ä¸ªæœˆåï¼‰

- âœ… **æ˜“äºæ‰©å±•**
  - æ·»åŠ æ–°åŠŸèƒ½æ—¶ä¸å½±å“ç°æœ‰æ¨¡å—
  - é€šè¿‡äº‹ä»¶æ€»çº¿è½»æ¾é›†æˆæ–°ç»„ä»¶
  - æ¨¡å—å¯ç‹¬ç«‹æ¼”è¿›

- âœ… **æ˜“äºæµ‹è¯•**
  - æ¯ä¸ªé¢†åŸŸå¯ç‹¬ç«‹æµ‹è¯•
  - Actor å¯æ¨¡æ‹Ÿæ¶ˆæ¯è¿›è¡Œæµ‹è¯•
  - äº‹ä»¶æ€»çº¿ä¾¿äºé›†æˆæµ‹è¯•

- âœ… **æ›´å¥½çš„é”™è¯¯å¤„ç†**
  - äº‹ä»¶æ€»çº¿å¯é›†ä¸­å¤„ç†é”™è¯¯
  - Actor éš”ç¦»æ•…éšœ
  - æ›´å¥½çš„é”™è¯¯è¿½è¸ª

---

## ğŸ’¡ å¯é€‰ä¼˜åŒ–

å¦‚æœæ—¶é—´å……è¶³ï¼Œå¯ä»¥è€ƒè™‘ä»¥ä¸‹ä¼˜åŒ–ï¼š

### 1. ä¾èµ–æ³¨å…¥æ¡†æ¶

ä½¿ç”¨ `shaku` crate å®ç°ä¾èµ–æ³¨å…¥ï¼š

```rust
use shaku::{Component, Interface, HasComponent, module};

module! {
    AppModule {
        components = [
            CaptureManager,
            AnalysisManager,
            StorageManager,
        ],
        providers = []
    }
}

// è‡ªåŠ¨ç®¡ç†ä¾èµ–å…³ç³»
let app_module = AppModule::builder()
    .with_component_parameters::<CaptureManager>(CaptureManagerParams { ... })
    .build();
```

**æ”¶ç›Š**: è‡ªåŠ¨ç®¡ç†ä¾èµ–ï¼Œç®€åŒ–æµ‹è¯•

---

### 2. é…ç½®çƒ­é‡è½½

ç›‘å¬é…ç½®æ–‡ä»¶å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°ï¼š

```rust
use notify::{Watcher, RecursiveMode, watcher};

impl SettingsManager {
    pub fn watch_config_changes(&self, event_bus: Arc<EventBus>) {
        let (tx, rx) = channel();
        let mut watcher = watcher(tx, Duration::from_secs(2)).unwrap();

        watcher.watch(&self.config_path, RecursiveMode::NonRecursive).unwrap();

        tokio::spawn(async move {
            while let Ok(event) = rx.recv() {
                // é…ç½®æ–‡ä»¶å˜åŒ–ï¼Œå‘å¸ƒäº‹ä»¶
                event_bus.publish(AppEvent::ConfigUpdated {
                    config_type: "settings".to_string(),
                });
            }
        });
    }
}
```

**æ”¶ç›Š**: æ— éœ€é‡å¯åº”ç”¨å³å¯æ›´æ–°é…ç½®

---

### 3. æ€§èƒ½ç›‘æ§

è®°å½•æ¯ä¸ªäº‹ä»¶çš„å¤„ç†æ—¶é—´ï¼š

```rust
impl EventBus {
    pub fn publish_with_metrics(&self, event: AppEvent) {
        let start = Instant::now();
        self.publish(event);
        let duration = start.elapsed();

        metrics::histogram!("event_publish_duration", duration.as_micros() as f64);
    }
}
```

**æ”¶ç›Š**: è¯†åˆ«æ€§èƒ½ç“¶é¢ˆï¼ŒæŒç»­ä¼˜åŒ–

---

### 4. ä¼˜é›…å…³é—­

ç¡®ä¿æ‰€æœ‰ Actor å®Œæˆå½“å‰ä»»åŠ¡åå†é€€å‡ºï¼š

```rust
pub struct GracefulShutdown {
    shutdown_tx: broadcast::Sender<()>,
}

impl GracefulShutdown {
    pub async fn shutdown(&self) {
        // å‘é€å…³é—­ä¿¡å·
        let _ = self.shutdown_tx.send(());

        // ç­‰å¾…æ‰€æœ‰ Actor å®Œæˆ
        tokio::time::sleep(Duration::from_secs(5)).await;
    }
}
```

**æ”¶ç›Š**: é¿å…æ•°æ®ä¸¢å¤±ï¼Œå®‰å…¨é€€å‡º

---

## ğŸ“š å‚è€ƒèµ„æ–™

### Actor æ¨¡å¼

- [Tokio Tutorial - Channels](https://tokio.rs/tokio/tutorial/channels)
- [Actix - Actor Framework](https://actix.rs/)
- [The Actor Model in Rust](https://ryhl.io/blog/actors-with-tokio/)

### äº‹ä»¶é©±åŠ¨æ¶æ„

- [Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
- [Building Event-Driven Microservices](https://www.oreilly.com/library/view/building-event-driven-microservices/9781492057888/)

### é¢†åŸŸé©±åŠ¨è®¾è®¡

- [Domain-Driven Design](https://martinfowler.com/tags/domain%20driven%20design.html)
- [DDD in Rust](https://github.com/ddd-crew/ddd-starter-modelling-process)

---

## âœ… æ£€æŸ¥æ¸…å•

### é˜¶æ®µä¸€å®Œæˆæ£€æŸ¥ âœ… å·²å®Œæˆ

- [x] 4 ä¸ªé¢†åŸŸç®¡ç†å™¨å·²åˆ›å»º
- [x] AppState å·²é‡æ„ä¸º 5 ä¸ªå­—æ®µ
- [x] æ‰€æœ‰ Tauri å‘½ä»¤å·²æ›´æ–°
- [x] `analysis_lock` å·²ç§»é™¤
- [x] ç¼–è¯‘æ— é”™è¯¯
- [x] æ‰€æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ (å¾…ç”¨æˆ·æµ‹è¯•)

### é˜¶æ®µäºŒå®Œæˆæ£€æŸ¥ â¸ï¸ éƒ¨åˆ†å®Œæˆ

- [x] EventBus å·²å®ç°
- [x] CaptureScheduler èƒ½å‘å¸ƒäº‹ä»¶
- [ ] LLMProcessor èƒ½è®¢é˜…äº‹ä»¶ (TODO: è§åç»­å·¥ä½œæŒ‡å—)
- [ ] VideoProcessor èƒ½è®¢é˜…äº‹ä»¶ (TODO: è§åç»­å·¥ä½œæŒ‡å—)
- [ ] äº‹ä»¶æµæµ‹è¯•é€šè¿‡ (TODO: éœ€å®Œæˆç›‘å¬å™¨åæµ‹è¯•)
- [x] æ¨¡å—é—´è§£è€¦ (CaptureSchedulerå·²è§£è€¦)

### é˜¶æ®µä¸‰å®Œæˆæ£€æŸ¥ â¸ï¸ æœªå¼€å§‹

- [ ] LLMManagerActor å·²å®ç°
- [ ] SystemStatusActor å·²å®ç°
- [ ] CaptureSettingsActor å·²å®ç°
- [ ] æ‰€æœ‰ Actor æ­£å¸¸å¯åŠ¨
- [ ] æ‰€æœ‰ `Arc<Mutex>` å·²ç§»é™¤
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] æ— æ­»é”é£é™©

---

## ğŸ¯ æ€»ç»“

æœ¬é‡æ„æ–¹æ¡ˆé€šè¿‡**ä¸‰é˜¶æ®µæ¸è¿›å¼**æ”¹é€ ï¼Œç³»ç»Ÿåœ°è§£å†³äº†ä»£ç å®¡æŸ¥ä¸­å‘ç°çš„ä¸‰ä¸ªæ ¸å¿ƒæ¶æ„é—®é¢˜ï¼š

### æ ¸å¿ƒæ”¹è¿›

1. **çŠ¶æ€ç®¡ç†é‡æ„** - å°†æ··ä¹±çš„ 11 ä¸ªå­—æ®µé‡ç»„ä¸º 4 ä¸ªæ¸…æ™°çš„é¢†åŸŸ
2. **ä¾èµ–è§£è€¦** - å¼•å…¥äº‹ä»¶æ€»çº¿ï¼Œæ¨¡å—é—´é€šè¿‡å‘å¸ƒ/è®¢é˜…é€šä¿¡
3. **å¹¶å‘ä¼˜åŒ–** - ç”¨ Actor æ¨¡å¼æ›¿ä»£é”ï¼Œæ¶ˆé™¤æ­»é”é£é™©

### å…³é”®æ”¶ç›Š

- âœ… **æ€§èƒ½æå‡ 20-30%** - æ¶ˆé™¤é”ç«äº‰
- âœ… **å¯ç»´æŠ¤æ€§æå‡ 40%** - æ¸…æ™°çš„æ¶æ„
- âœ… **æ­»é”é£é™©é™ä¸º 0** - Actor æ¨¡å¼ä¿è¯
- âœ… **ä»£ç æ›´æ˜“æµ‹è¯•** - æ¨¡å—ç‹¬ç«‹

### å®æ–½è·¯å¾„

å»ºè®®æŒ‰é˜¶æ®µå®æ–½ï¼Œæ¯ä¸ªé˜¶æ®µå®Œæˆåè¿›è¡Œå……åˆ†æµ‹è¯•å†ç»§ç»­ï¼š

- **Week 1**: çŠ¶æ€ç®¡ç†é‡æ„ï¼ˆ6-8hï¼‰
- **Week 2**: ä¾èµ–è§£è€¦ï¼ˆ4-6hï¼‰
- **Week 3**: å¹¶å‘ä¼˜åŒ–ï¼ˆ8-10hï¼‰

**æ€»è®¡**: 18-24 å°æ—¶ï¼Œ3 å‘¨å®Œæˆ

---

## ğŸ“ åç»­å·¥ä½œæŒ‡å—

### ğŸ¯ ä¼˜å…ˆçº§1: å®Œæˆé˜¶æ®µäºŒäº‹ä»¶ç›‘å¬å™¨ (é¢„è®¡4-6å°æ—¶)

#### 1. LLMProcessoräº‹ä»¶ç›‘å¬å™¨

**ä½ç½®**: `src-tauri/src/llm/mod.rs`

**éœ€è¦å®ç°**:
```rust
impl LLMProcessor {
    /// å¯åŠ¨äº‹ä»¶ç›‘å¬å™¨
    pub async fn start_event_listener(self: Arc<Self>, event_bus: Arc<EventBus>) {
        let mut receiver = event_bus.subscribe();

        tokio::spawn(async move {
            info!("LLMå¤„ç†å™¨äº‹ä»¶ç›‘å¬å™¨å·²å¯åŠ¨");

            while let Ok(event) = receiver.recv().await {
                match event {
                    AppEvent::SessionCompleted { session_id, frame_count } => {
                        // å¤„ç†ä¼šè¯å®Œæˆäº‹ä»¶
                        // 1. è¯»å–ä¼šè¯å¸§
                        // 2. è°ƒç”¨LLMåˆ†æ
                        // 3. å‘å¸ƒAnalysisCompletedæˆ–AnalysisFailedäº‹ä»¶
                    }
                    _ => {}
                }
            }
        });
    }
}
```

#### 2. VideoProcessoräº‹ä»¶ç›‘å¬å™¨

**ä½ç½®**: `src-tauri/src/video/processor.rs`

**éœ€è¦å®ç°**:
```rust
impl VideoProcessor {
    /// å¯åŠ¨äº‹ä»¶ç›‘å¬å™¨
    pub async fn start_event_listener(self: Arc<Self>, event_bus: Arc<EventBus>) {
        let mut receiver = event_bus.subscribe();

        tokio::spawn(async move {
            info!("è§†é¢‘å¤„ç†å™¨äº‹ä»¶ç›‘å¬å™¨å·²å¯åŠ¨");

            while let Ok(event) = receiver.recv().await {
                match event {
                    AppEvent::AnalysisCompleted { session_id, .. } => {
                        // å¤„ç†åˆ†æå®Œæˆäº‹ä»¶
                        // 1. ç”Ÿæˆè§†é¢‘
                        // 2. å‘å¸ƒVideoGeneratedæˆ–VideoGenerationFailedäº‹ä»¶
                    }
                    _ => {}
                }
            }
        });
    }
}
```

#### 3. å¯åŠ¨ç›‘å¬å™¨

**ä½ç½®**: `src-tauri/src/lib.rs:1706-1711`

**ä¿®æ”¹**:
```rust
// TODO: æ·»åŠ LLMProcessorå’ŒVideoProcessorçš„äº‹ä»¶ç›‘å¬å™¨
// åˆ›å»ºå¤„ç†å™¨å®ä¾‹
let llm_processor = Arc::new(LLMProcessor::new(...));
let video_processor = state_clone.analysis_domain.get_video_processor().clone();

// å¯åŠ¨äº‹ä»¶ç›‘å¬å™¨
llm_processor.clone().start_event_listener(state_clone.event_bus.clone()).await;
video_processor.clone().start_event_listener(state_clone.event_bus.clone()).await;
```

### ğŸ¯ ä¼˜å…ˆçº§2: æµ‹è¯•äº‹ä»¶æµ

1. è¿è¡Œåº”ç”¨ï¼Œè§¦å‘æˆªå±
2. è§‚å¯Ÿæ—¥å¿—ç¡®è®¤äº‹ä»¶å‘å¸ƒ: `ä¼šè¯äº‹ä»¶å·²å‘å¸ƒ`
3. ç¡®è®¤LLMå¤„ç†å™¨æ”¶åˆ°äº‹ä»¶: `æ”¶åˆ°ä¼šè¯å®Œæˆäº‹ä»¶`
4. ç¡®è®¤è§†é¢‘ç”Ÿæˆ: `æ”¶åˆ°åˆ†æå®Œæˆäº‹ä»¶`

### ğŸ¯ ä¼˜å…ˆçº§3: é˜¶æ®µä¸‰Actoræ¨¡å¼ (é¢„è®¡8-10å°æ—¶)

å‚è€ƒæ–¹æ¡ˆæ–‡æ¡£ç¬¬620-1008è¡Œçš„è¯¦ç»†è®¾è®¡ã€‚

### âš ï¸ æ³¨æ„äº‹é¡¹

1. **äº‹ä»¶å¤„ç†é¡ºåº**: SessionCompleted â†’ AnalysisCompleted â†’ VideoGenerated
2. **é”™è¯¯å¤„ç†**: æ¯ä¸ªç›‘å¬å™¨éƒ½è¦å‘å¸ƒå¤±è´¥äº‹ä»¶ (AnalysisFailed/VideoGenerationFailed)
3. **èµ„æºæ¸…ç†**: åŸæœ¬åœ¨schedulerä¸­çš„å›¾ç‰‡æ¸…ç†é€»è¾‘éœ€è¦ç§»åˆ°å¤„ç†å™¨ä¸­
4. **æ•°æ®åº“æ“ä½œ**: æ‰€æœ‰ä¼šè¯ç›¸å…³çš„æ•°æ®åº“æ“ä½œéœ€è¦åœ¨äº‹ä»¶å¤„ç†å™¨ä¸­å®Œæˆ

### ğŸ“ ç›¸å…³æ–‡ä»¶

- `src-tauri/src/event_bus.rs` - äº‹ä»¶æ€»çº¿å®ç°
- `src-tauri/src/capture/scheduler.rs` - å·²æ”¹ä¸ºäº‹ä»¶é©±åŠ¨
- `src-tauri/src/llm/mod.rs` - éœ€è¦æ·»åŠ ç›‘å¬å™¨
- `src-tauri/src/video/processor.rs` - éœ€è¦æ·»åŠ ç›‘å¬å™¨
- `src-tauri/src/lib.rs` - éœ€è¦å¯åŠ¨ç›‘å¬å™¨

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.1
**æœ€åæ›´æ–°**: 2025-10-01
**ç»´æŠ¤è€…**: Claude Code
