# Tauri + Rust 屏幕活动分析系统 - 完整技术方案

## 项目架构

```
screen-analyzer/
├── src-tauri/              # Rust 后端
│   ├── src/
│   │   ├── main.rs         # 主入口
│   │   ├── capture/        # 截屏模块
│   │   │   ├── mod.rs
│   │   │   └── scheduler.rs
│   │   ├── video/          # 视频处理模块
│   │   │   ├── mod.rs
│   │   │   └── processor.rs
│   │   ├── llm/            # LLM 接口模块
│   │   │   ├── mod.rs
│   │   │   ├── openai.rs
│   │   │   ├── anthropic.rs
│   │   │   └── plugin.rs
│   │   ├── storage/        # 存储管理
│   │   │   ├── mod.rs
│   │   │   ├── database.rs
│   │   │   └── cleaner.rs
│   │   └── models/         # 数据模型
│   │       └── mod.rs
│   ├── Cargo.toml
│   └── tauri.conf.json
├── src/                    # 前端
│   ├── App.vue
│   ├── components/
│   │   ├── Calendar.vue
│   │   ├── Timeline.vue
│   │   ├── Settings.vue
│   │   └── VideoPlayer.vue
│   ├── stores/
│   │   └── activity.js
│   └── main.js
├── package.json
└── README.md
```

## 核心依赖配置

### `Cargo.toml`
```toml
[package]
name = "screen-analyzer"
version = "0.1.0"
edition = "2021"

[dependencies]
tauri = { version = "1.5", features = ["shell-open", "fs-all", "path-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1", features = ["full"] }
screenshots = "0.8"  # 跨平台截屏
image = "0.24"  # 图像处理
ffmpeg-next = "6.0"  # 视频处理
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite"] }
chrono = { version = "0.4", features = ["serde"] }
reqwest = { version = "0.11", features = ["json"] }
async-trait = "0.1"
base64 = "0.21"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
cron = "0.12"  # 定时任务

[build-dependencies]
tauri-build = { version = "1.5", features = [] }
```

## 详细实现方案

### 1. 截屏模块 (`src-tauri/src/capture/`)

```rust
// capture/mod.rs
use screenshots::Screen;
use image::{DynamicImage, ImageBuffer, Rgba};
use std::sync::Arc;
use tokio::sync::Mutex;
use chrono::{DateTime, Utc};
use std::path::PathBuf;

pub struct ScreenCapture {
    screens: Vec<Screen>,
    output_dir: PathBuf,
    current_session: Arc<Mutex<Vec<ScreenFrame>>>,
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct ScreenFrame {
    pub timestamp: DateTime<Utc>,
    pub file_path: String,
    pub screen_id: usize,
}

impl ScreenCapture {
    pub fn new(output_dir: PathBuf) -> Self {
        let screens = Screen::all().unwrap();
        Self {
            screens,
            output_dir,
            current_session: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub async fn capture_frame(&self) -> Result<ScreenFrame, anyhow::Error> {
        let timestamp = Utc::now();
        let primary_screen = &self.screens[0];
        let image = primary_screen.capture()?;
        
        // 保存为 JPEG 以节省空间
        let file_name = format!("{}.jpg", timestamp.timestamp_millis());
        let file_path = self.output_dir.join(&file_name);
        
        // 调整分辨率到 1920x1080
        let resized = self.resize_image(image, 1920, 1080)?;
        resized.save(&file_path)?;
        
        let frame = ScreenFrame {
            timestamp,
            file_path: file_path.to_string_lossy().to_string(),
            screen_id: 0,
        };
        
        self.current_session.lock().await.push(frame.clone());
        Ok(frame)
    }

    fn resize_image(&self, img: DynamicImage, width: u32, height: u32) -> Result<DynamicImage, anyhow::Error> {
        Ok(img.resize_exact(width, height, image::imageops::FilterType::Lanczos3))
    }
}

// capture/scheduler.rs
use tokio::time::{interval, Duration};
use super::ScreenCapture;

pub struct CaptureScheduler {
    capture: Arc<ScreenCapture>,
    llm_processor: Arc<LLMProcessor>,
}

impl CaptureScheduler {
    pub async fn start(&self) {
        let capture = self.capture.clone();
        let llm_processor = self.llm_processor.clone();
        
        // 1 FPS 截屏任务
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(1));
            loop {
                interval.tick().await;
                if let Err(e) = capture.capture_frame().await {
                    tracing::error!("Failed to capture frame: {}", e);
                }
            }
        });
        
        // 15分钟总结任务
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(15 * 60));
            loop {
                interval.tick().await;
                if let Err(e) = llm_processor.process_session().await {
                    tracing::error!("Failed to process session: {}", e);
                }
            }
        });
    }
}
```

### 2. LLM 插件系统 (`src-tauri/src/llm/`)

```rust
// llm/plugin.rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActivityTag {
    pub category: ActivityCategory,
    pub confidence: f32,
    pub keywords: Vec<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ActivityCategory {
    Work,           // 工作
    Personal,       // 私人
    Break,          // 中断/休息
    Idle,           // 空闲
    Meeting,        // 会议
    Coding,         // 编程
    Research,       // 研究/学习
    Communication,  // 沟通（邮件、聊天）
    Entertainment,  // 娱乐
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SessionSummary {
    pub title: String,
    pub summary: String,
    pub tags: Vec<ActivityTag>,
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub key_moments: Vec<KeyMoment>,
}

#[async_trait]
pub trait LLMProvider: Send + Sync {
    async fn analyze_frames(&self, frames: Vec<String>) -> Result<SessionSummary, anyhow::Error>;
    fn name(&self) -> &str;
    fn configure(&mut self, config: serde_json::Value) -> Result<(), anyhow::Error>;
}

// llm/openai.rs
pub struct OpenAIProvider {
    api_key: String,
    model: String,
    client: reqwest::Client,
}

#[async_trait]
impl LLMProvider for OpenAIProvider {
    async fn analyze_frames(&self, frames: Vec<String>) -> Result<SessionSummary, anyhow::Error> {
        // 将帧采样（每30秒一帧）并转换为base64
        let sampled_frames = self.sample_frames(frames, 30)?;
        
        let prompt = r#"
        分析这些屏幕截图，生成15分钟活动总结：
        1. 识别主要活动类型（工作/私人/休息/空闲等）
        2. 生成简短标题（10字以内）
        3. 生成详细摘要（50-100字）
        4. 标记关键时刻
        
        返回JSON格式：
        {
            "title": "简短标题",
            "summary": "详细描述用户在做什么",
            "tags": [
                {"category": "Work", "confidence": 0.9, "keywords": ["coding", "IDE"]}
            ],
            "key_moments": [
                {"time": "00:03:20", "description": "开始编写代码"}
            ]
        }
        "#;
        
        // 调用 OpenAI Vision API
        let response = self.call_vision_api(prompt, sampled_frames).await?;
        Ok(self.parse_response(response)?)
    }
}

// llm/mod.rs - LLM管理器
pub struct LLMManager {
    providers: HashMap<String, Box<dyn LLMProvider>>,
    active_provider: String,
}

impl LLMManager {
    pub fn new() -> Self {
        let mut providers = HashMap::new();
        
        // 注册默认提供商
        providers.insert("openai".to_string(), 
            Box::new(OpenAIProvider::new()) as Box<dyn LLMProvider>);
        providers.insert("anthropic".to_string(), 
            Box::new(AnthropicProvider::new()) as Box<dyn LLMProvider>);
        
        Self {
            providers,
            active_provider: "openai".to_string(),
        }
    }
    
    pub fn register_provider(&mut self, name: String, provider: Box<dyn LLMProvider>) {
        self.providers.insert(name, provider);
    }
}
```

### 3. 视频处理模块 (`src-tauri/src/video/`)

```rust
// video/processor.rs
use ffmpeg_next as ffmpeg;
use std::path::{Path, PathBuf};

pub struct VideoProcessor {
    output_dir: PathBuf,
}

impl VideoProcessor {
    pub async fn create_summary_video(
        &self,
        frames: Vec<String>,
        output_path: &Path,
        speed_multiplier: f32,
    ) -> Result<String, anyhow::Error> {
        // FFmpeg 命令生成15分钟回顾视频
        // 1 FPS * 15分钟 = 900帧
        // 20倍速播放 = 45秒视频
        
        let temp_list = self.create_frame_list(&frames)?;
        
        // 使用 ffmpeg-next 或调用系统 FFmpeg
        let output = std::process::Command::new("ffmpeg")
            .args(&[
                "-f", "concat",
                "-safe", "0",
                "-i", temp_list.to_str().unwrap(),
                "-vf", &format!("scale=1920:1080,setpts=PTS/{}", speed_multiplier),
                "-c:v", "libx264",
                "-crf", "23",
                "-preset", "fast",
                "-y",
                output_path.to_str().unwrap(),
            ])
            .output()?;
            
        Ok(output_path.to_string_lossy().to_string())
    }
}
```

### 4. 存储管理 (`src-tauri/src/storage/`)

```rust
// storage/database.rs
use sqlx::{SqlitePool, sqlite::SqlitePoolOptions};

pub struct Database {
    pool: SqlitePool,
}

impl Database {
    pub async fn new(db_path: &str) -> Result<Self, anyhow::Error> {
        let pool = SqlitePoolOptions::new()
            .max_connections(5)
            .connect(db_path).await?;
            
        // 创建表
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                start_time DATETIME NOT NULL,
                end_time DATETIME NOT NULL,
                title TEXT NOT NULL,
                summary TEXT NOT NULL,
                video_path TEXT,
                tags TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        "#).execute(&pool).await?;
        
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS frames (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id INTEGER,
                timestamp DATETIME NOT NULL,
                file_path TEXT NOT NULL,
                FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
            )
        "#).execute(&pool).await?;
        
        Ok(Self { pool })
    }
}

// storage/cleaner.rs
use tokio::time::{interval, Duration};
use chrono::{Utc, Duration as ChronoDuration};

pub struct StorageCleaner {
    db: Arc<Database>,
    retention_days: i64,
    max_retention_days: i64,
}

impl StorageCleaner {
    pub fn new(db: Arc<Database>) -> Self {
        Self {
            db,
            retention_days: 7,  // 默认7天
            max_retention_days: 30,
        }
    }
    
    pub async fn start_cleanup_task(&self) {
        let db = self.db.clone();
        let retention_days = self.retention_days;
        
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(3600)); // 每小时检查
            
            loop {
                interval.tick().await;
                let cutoff_date = Utc::now() - ChronoDuration::days(retention_days);
                
                // 删除过期数据
                if let Err(e) = db.delete_old_sessions(cutoff_date).await {
                    tracing::error!("Failed to clean old sessions: {}", e);
                }
            }
        });
    }
    
    pub fn set_retention_days(&mut self, days: i64) -> Result<(), &str> {
        if days > self.max_retention_days {
            return Err("Retention days cannot exceed 30");
        }
        self.retention_days = days;
        Ok(())
    }
}
```

### 5. 前端实现 (`src/`)

```vue
<!-- src/App.vue -->
<template>
  <div id="app">
    <el-container>
      <el-header>
        <h1>屏幕活动分析器</h1>
        <el-button @click="showSettings = true">设置</el-button>
      </el-header>
      
      <el-main>
        <el-row :gutter="20">
          <!-- 日历视图 -->
          <el-col :span="16">
            <CalendarView 
              :activities="activities"
              @date-select="handleDateSelect"
            />
          </el-col>
          
          <!-- 当日时间线 -->
          <el-col :span="8">
            <TimelineView 
              :date="selectedDate"
              :sessions="daySessions"
              @session-click="handleSessionClick"
            />
          </el-col>
        </el-row>
        
        <!-- 会话详情 -->
        <SessionDetail 
          v-if="selectedSession"
          :session="selectedSession"
          @close="selectedSession = null"
        />
      </el-main>
    </el-container>
    
    <!-- 设置对话框 -->
    <SettingsDialog 
      v-model:visible="showSettings"
      :config="appConfig"
      @update="updateConfig"
    />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { invoke } from '@tauri-apps/api/tauri'
import CalendarView from './components/CalendarView.vue'
import TimelineView from './components/TimelineView.vue'
import SessionDetail from './components/SessionDetail.vue'
import SettingsDialog from './components/SettingsDialog.vue'

const activities = ref([])
const selectedDate = ref(new Date())
const daySessions = ref([])
const selectedSession = ref(null)
const showSettings = ref(false)
const appConfig = ref({
  retentionDays: 7,
  llmProvider: 'openai',
  captureInterval: 1,
  summaryInterval: 15
})

onMounted(async () => {
  // 加载活动数据
  activities.value = await invoke('get_activities', {
    startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
    endDate: new Date()
  })
})

const handleDateSelect = async (date) => {
  selectedDate.value = date
  daySessions.value = await invoke('get_day_sessions', { date })
}

const handleSessionClick = async (session) => {
  selectedSession.value = await invoke('get_session_detail', { 
    sessionId: session.id 
  })
}

const updateConfig = async (newConfig) => {
  await invoke('update_config', { config: newConfig })
  appConfig.value = newConfig
}
</script>
```

```vue
<!-- src/components/CalendarView.vue -->
<template>
  <div class="calendar-container">
    <el-calendar v-model="currentDate">
      <template #date-cell="{ data }">
        <div class="calendar-cell" @click="selectDate(data.day)">
          <div class="date">{{ data.day.split('-').slice(2).join('') }}</div>
          <div class="activities-preview">
            <ActivitySummary 
              v-if="getDateActivities(data.day)"
              :activities="getDateActivities(data.day)"
            />
          </div>
        </div>
      </template>
    </el-calendar>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  activities: Array
})

const emit = defineEmits(['date-select'])

const currentDate = ref(new Date())

const getDateActivities = (dateStr) => {
  return props.activities.filter(a => 
    a.date === dateStr
  )
}

const selectDate = (date) => {
  emit('date-select', new Date(date))
}
</script>
```

### 6. Tauri 命令接口 (`src-tauri/src/main.rs`)

```rust
use tauri::Manager;
use std::sync::Arc;
use tokio::sync::Mutex;

mod capture;
mod video;
mod llm;
mod storage;
mod models;

use capture::{ScreenCapture, CaptureScheduler};
use storage::{Database, StorageCleaner};
use llm::LLMManager;

#[derive(Clone)]
struct AppState {
    capture: Arc<ScreenCapture>,
    db: Arc<Database>,
    llm_manager: Arc<Mutex<LLMManager>>,
    cleaner: Arc<StorageCleaner>,
}

#[tauri::command]
async fn get_activities(
    state: tauri::State<'_, AppState>,
    start_date: String,
    end_date: String,
) -> Result<Vec<models::Activity>, String> {
    state.db
        .get_activities(&start_date, &end_date)
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
async fn get_day_sessions(
    state: tauri::State<'_, AppState>,
    date: String,
) -> Result<Vec<models::Session>, String> {
    state.db
        .get_sessions_by_date(&date)
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
async fn get_session_detail(
    state: tauri::State<'_, AppState>,
    session_id: i64,
) -> Result<models::SessionDetail, String> {
    state.db
        .get_session_detail(session_id)
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
async fn update_config(
    state: tauri::State<'_, AppState>,
    config: models::AppConfig,
) -> Result<(), String> {
    // 更新配置
    if let Some(retention_days) = config.retention_days {
        state.cleaner
            .set_retention_days(retention_days)
            .map_err(|e| e.to_string())?;
    }
    
    if let Some(llm_provider) = config.llm_provider {
        let mut llm = state.llm_manager.lock().await;
        llm.set_active_provider(&llm_provider);
    }
    
    Ok(())
}

#[tauri::command]
async fn add_manual_tag(
    state: tauri::State<'_, AppState>,
    session_id: i64,
    tag: models::ActivityTag,
) -> Result<(), String> {
    state.db
        .add_session_tag(session_id, tag)
        .await
        .map_err(|e| e.to_string())
}

fn main() {
    tauri::Builder::default()
        .setup(|app| {
            let app_dir = app.path_resolver().app_data_dir().unwrap();
            
            // 初始化运行时
            let runtime = tokio::runtime::Runtime::new().unwrap();
            
            let (capture, db, llm_manager, cleaner) = runtime.block_on(async {
                let db = Database::new(&app_dir.join("data.db").to_string_lossy())
                    .await
                    .unwrap();
                let db = Arc::new(db);
                
                let capture = Arc::new(ScreenCapture::new(app_dir.join("frames")));
                let llm_manager = Arc::new(Mutex::new(LLMManager::new()));
                let cleaner = Arc::new(StorageCleaner::new(db.clone()));
                
                (capture, db, llm_manager, cleaner)
            });
            
            // 启动后台任务
            runtime.spawn(async move {
                let scheduler = CaptureScheduler::new(capture.clone(), llm_manager.clone());
                scheduler.start().await;
                cleaner.start_cleanup_task().await;
            });
            
            let state = AppState {
                capture,
                db,
                llm_manager,
                cleaner,
            };
            
            app.manage(state);
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            get_activities,
            get_day_sessions,
            get_session_detail,
            update_config,
            add_manual_tag,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 7. 配置文件 (`tauri.conf.json`)

```json
{
  "build": {
    "beforeDevCommand": "npm run dev",
    "beforeBuildCommand": "npm run build",
    "devPath": "http://localhost:1420",
    "distDir": "../dist"
  },
  "package": {
    "productName": "Screen Analyzer",
    "version": "1.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "fs": {
        "all": true,
        "scope": ["$APPDATA", "$APPDATA/**"]
      },
      "path": {
        "all": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.screenanalyzer.app",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "屏幕活动分析器",
        "width": 1400,
        "height": 900,
        "minWidth": 1200,
        "minHeight": 700
      }
    ],
    "systemTray": {
      "iconPath": "icons/icon.png",
      "iconAsTemplate": true
    }
  }
}
```

## 构建和运行指令

```bash
# 安装依赖
npm install

# 安装 Rust 依赖
cd src-tauri
cargo build

# 开发模式运行
npm run tauri dev

# 构建生产版本
npm run tauri build

# 生成 Windows 安装包
npm run tauri build -- --target x86_64-pc-windows-msvc

# 生成 macOS 应用
npm run tauri build -- --target universal-apple-darwin
```

## 关键特性实现说明

1. **插件式 LLM**：通过 trait 定义统一接口，可以轻松添加新的 LLM 提供商
2. **自动清理**：后台任务定期清理过期文件，可配置保留时间
3. **视频生成**：使用 FFmpeg 将截图合并为加速视频
4. **智能标签**：LLM 自动识别活动类型，支持手动修正
5. **日历视图**：直观展示每日活动，支持快速导航

## 开发建议

1. 先实现核心截屏和存储功能
2. 逐步添加 LLM 分析能力
3. 最后完善 UI 交互和视频处理
4. 使用 Cursor/GitHub Copilot 辅助实现具体功能

这个方案提供了完整的架构和关键代码，可以直接交给 AI Coding 工具逐步实现。需要我详细展开某个模块的实现吗？